<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Potato Blight Risk Predictor - Cape Breton</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #e8f5e9 0%, #e3f2fd 100%);
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        .header {
            background: white;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .header-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .title {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .icon {
            width: 40px;
            height: 40px;
            color: #2e7d32;
        }
        
        h1 {
            font-size: 24px;
            color: #1b5e20;
        }
        
        .subtitle {
            font-size: 14px;
            color: #666;
        }
        
        .upload-btn {
            background: #2e7d32;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .upload-btn:hover {
            background: #1b5e20;
        }
        
        .data-loaded {
            color: #2e7d32;
            font-weight: 600;
            font-size: 14px;
        }
        
        .chat-container {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }
        
        .messages {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        
        .message {
            display: flex;
            animation: fadeIn 0.3s ease-in;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .message.user {
            justify-content: flex-end;
        }
        
        .message.assistant {
            justify-content: flex-start;
        }
        
        .message-content {
            max-width: 70%;
            padding: 16px;
            border-radius: 12px;
            white-space: pre-line;
            line-height: 1.6;
        }
        
        .message.user .message-content {
            background: #2e7d32;
            color: white;
        }
        
        .message.assistant .message-content {
            background: white;
            color: #333;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .assistant-label {
            font-size: 12px;
            color: #2e7d32;
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .input-container {
            background: white;
            border-top: 1px solid #ddd;
            padding: 20px;
        }
        
        .input-wrapper {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            gap: 12px;
        }
        
        input[type="text"] {
            flex: 1;
            padding: 14px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            outline: none;
        }
        
        input[type="text"]:focus {
            border-color: #2e7d32;
        }
        
        .send-btn {
            background: #2e7d32;
            color: white;
            padding: 14px 32px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
        }
        
        .send-btn:hover:not(:disabled) {
            background: #1b5e20;
        }
        
        .send-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .loading {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #666;
        }
        
        .spinner {
            width: 16px;
            height: 16px;
            border: 2px solid #e0e0e0;
            border-top-color: #2e7d32;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        input[type="file"] {
            display: none;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-content">
            <div class="title">
                <svg class="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6" />
                </svg>
                <div>
                    <h1>Potato Blight Risk Predictor</h1>
                    <div class="subtitle">Smart Weather-Based Analysis</div>
                </div>
            </div>
            <div id="uploadArea">
                <label for="fileInput" class="upload-btn">
                    <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                    </svg>
                    Upload Data
                </label>
                <input type="file" id="fileInput" accept=".csv,.tsv,.txt">
            </div>
        </div>
    </div>

    <div class="chat-container" id="chatContainer">
        <div class="messages" id="messages">
            <div class="message assistant">
                <div class="message-content">
                    <div class="assistant-label">
                        <svg width="14" height="14" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
                        </svg>
                        Assistant
                    </div>
                    Hi! ðŸ‘‹ I'm your potato blight risk assistant.

Just ask me questions like:
â€¢ "What's the blight risk in Sydney, NS next week?"
â€¢ "Show me risk for Baddeck from June to August"
â€¢ "Analyze Halifax for the past month"
â€¢ "What about Cape Breton tomorrow?"

I'll fetch weather data and analyze blight risk for any location and time period!
                </div>
            </div>
        </div>
    </div>

    <div class="input-container">
        <div class="input-wrapper">
            <input 
                type="text" 
                id="userInput" 
                placeholder="Ask about blight risk... e.g., 'What's the risk in Sydney, NS next week?'"
            >
            <button class="send-btn" id="sendBtn">Send</button>
        </div>
    </div>

    <script>
        let weatherData = null;
        let analysisResults = null;

        // Major cities/locations in Nova Scotia with fallbacks
        const LOCATION_MAPPINGS = {
            'nova scotia': { name: 'Halifax', lat: 44.6488, lon: -63.5752 },
            'ns': { name: 'Halifax', lat: 44.6488, lon: -63.5752 },
            'halifax': { name: 'Halifax', lat: 44.6488, lon: -63.5752 },
            'sydney': { name: 'Sydney', lat: 46.1368, lon: -60.1942 },
            'cape breton': { name: 'Sydney', lat: 46.1368, lon: -60.1942 },
            'baddeck': { name: 'Baddeck', lat: 46.0994, lon: -60.7525 },
            'truro': { name: 'Truro', lat: 45.3674, lon: -63.2755 },
            'yarmouth': { name: 'Yarmouth', lat: 43.8377, lon: -66.1175 },
            'antigonish': { name: 'Antigonish', lat: 45.6219, lon: -61.9977 },
            'inverness': { name: 'Inverness', lat: 46.1999, lon: -61.1086 },
            'glace bay': { name: 'Glace Bay', lat: 46.1968, lon: -59.9570 }
        };

        // Geocode location using Nominatim
        async function geocodeLocation(locationText) {
            // Normalize and fix common typos
            const normalized = locationText.toLowerCase().trim()
                .replace(/sydeny/g, 'sydney')
                .replace(/hallifax/g, 'halifax')
                .replace(/baddek/g, 'baddeck');
            
            // Check if it's a known location first
            for (const [key, value] of Object.entries(LOCATION_MAPPINGS)) {
                if (normalized.includes(key)) {
                    return value;
                }
            }

            // Try geocoding
            try {
                const response = await fetch(
                    `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(locationText)}, Nova Scotia, Canada&limit=1`,
                    { headers: { 'User-Agent': 'BlightPredictor/1.0' } }
                );
                const data = await response.json();
                if (data && data.length > 0) {
                    return {
                        name: data[0].display_name.split(',')[0],
                        lat: parseFloat(data[0].lat),
                        lon: parseFloat(data[0].lon)
                    };
                }
            } catch (error) {
                console.error('Geocoding error:', error);
            }
            return null;
        }

        // Parse time expressions
        function parseTimeExpression(text) {
            const now = new Date();
            const lowerText = text.toLowerCase();

            // Questions about "last blight" - look at previous growing season
            if (lowerText.includes('last blight') || lowerText.includes('last period')) {
                const year = now.getMonth() < 5 ? now.getFullYear() - 1 : now.getFullYear();
                const start = new Date(year, 5, 1); // June 1
                const end = new Date(year, 8, 30); // Sept 30
                return { start, end, type: 'past', days: 122, season: true };
            }

            // Questions about "next blight" - look at upcoming growing season
            if (lowerText.includes('next blight') || lowerText.includes('next occur') || lowerText.includes('could occur')) {
                const year = now.getMonth() < 5 ? now.getFullYear() : now.getFullYear() + 1;
                const start = new Date(year, 5, 1); // June 1
                const end = new Date(year, 8, 30); // Sept 30
                return { start, end, type: 'future', days: 122, season: true, nextSeason: true };
            }

            // Future
            if (lowerText.includes('tomorrow')) {
                const tomorrow = new Date(now);
                tomorrow.setDate(tomorrow.getDate() + 1);
                return { start: tomorrow, end: tomorrow, type: 'future', days: 1 };
            }
            if (lowerText.includes('next week')) {
                const start = new Date(now);
                const end = new Date(now);
                end.setDate(end.getDate() + 7);
                return { start, end, type: 'future', days: 7 };
            }
            if (lowerText.includes('next month')) {
                const start = new Date(now);
                const end = new Date(now);
                end.setMonth(end.getMonth() + 1);
                return { start, end, type: 'future', days: 30 };
            }

            // Past
            if (lowerText.includes('yesterday')) {
                const yesterday = new Date(now);
                yesterday.setDate(yesterday.getDate() - 1);
                return { start: yesterday, end: yesterday, type: 'past', days: 1 };
            }
            if (lowerText.includes('past week') || lowerText.includes('last week')) {
                const start = new Date(now);
                start.setDate(start.getDate() - 7);
                return { start, end: now, type: 'past', days: 7 };
            }
            if (lowerText.includes('past month') || lowerText.includes('last month')) {
                const start = new Date(now);
                start.setMonth(start.getMonth() - 1);
                return { start, end: now, type: 'past', days: 30 };
            }
            if (lowerText.includes('past summer') || lowerText.includes('last summer')) {
                const year = now.getMonth() < 5 ? now.getFullYear() - 1 : now.getFullYear();
                const start = new Date(year, 5, 1);
                const end = new Date(year, 8, 30);
                return { start, end, type: 'past', days: 122, season: true };
            }

            // Specific months
            const months = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'];
            for (let i = 0; i < months.length; i++) {
                if (lowerText.includes(months[i])) {
                    // Determine year - if month already passed this year, use this year, otherwise last year
                    let year = now.getFullYear();
                    if (i > now.getMonth()) {
                        year = year - 1; // Month hasn't happened yet this year, use last year
                    }
                    const start = new Date(year, i, 1);
                    const end = new Date(year, i + 1, 0);
                    const isPast = end < now;
                    return { start, end, type: isPast ? 'past' : 'future', days: end.getDate() };
                }
            }

            // Default: check current month (winter = show it's winter, summer = show current risk)
            if (now.getMonth() >= 4 && now.getMonth() <= 8) {
                // May-September: show next 7 days
                const end = new Date(now);
                end.setDate(end.getDate() + 7);
                return { start: now, end, type: 'future', days: 7 };
            } else {
                // Winter: show last growing season
                const year = now.getMonth() < 5 ? now.getFullYear() - 1 : now.getFullYear();
                const start = new Date(year, 5, 1);
                const end = new Date(year, 8, 30);
                return { start, end, type: 'past', days: 122, season: true };
            }
        }

        // Fetch weather data from Open-Meteo
        async function fetchWeatherData(lat, lon, timeRange) {
            try {
                let url;
                if (timeRange.type === 'future') {
                    if (timeRange.nextSeason) {
                        // For next growing season (can't get forecast that far)
                        // Use historical average from previous years as proxy
                        return { useHistoricalProxy: true, message: "Long-range forecast not available" };
                    }
                    // Forecast API (up to 16 days)
                    url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&hourly=temperature_2m,relative_humidity_2m,precipitation,dewpoint_2m&forecast_days=${Math.min(timeRange.days, 16)}&timezone=America/Halifax`;
                } else {
                    // Historical API
                    const startDate = timeRange.start.toISOString().split('T')[0];
                    const endDate = timeRange.end.toISOString().split('T')[0];
                    url = `https://archive-api.open-meteo.com/v1/archive?latitude=${lat}&longitude=${lon}&start_date=${startDate}&end_date=${endDate}&hourly=temperature_2m,relative_humidity_2m,precipitation,dewpoint_2m&timezone=America/Halifax`;
                }

                const response = await fetch(url);
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Weather fetch error:', error);
                return null;
            }
        }

        // Convert weather API data to our format
        function convertWeatherData(apiData, lat, lon) {
            if (!apiData || !apiData.hourly) return [];

            const hourly = apiData.hourly;
            const dailyData = [];

            // Group hourly data into days
            for (let i = 0; i < hourly.time.length; i += 24) {
                const date = new Date(hourly.time[i]);
                const temps = [];
                const rhs = [];
                const dews = [];
                let precip = 0;

                for (let j = i; j < Math.min(i + 24, hourly.time.length); j++) {
                    temps.push(hourly.temperature_2m[j]);
                    rhs.push(hourly.relative_humidity_2m[j]);
                    dews.push(hourly.dewpoint_2m[j]);
                    precip += hourly.precipitation[j] || 0;
                }

                dailyData.push({
                    LAT: lat,
                    LON: lon,
                    YEAR: date.getFullYear(),
                    DOY: Math.floor((date - new Date(date.getFullYear(), 0, 0)) / 86400000),
                    T2M: temps.reduce((a, b) => a + b, 0) / temps.length,
                    RH2M: rhs.reduce((a, b) => a + b, 0) / rhs.length,
                    T2MDEW: dews.reduce((a, b) => a + b, 0) / dews.length,
                    PRECTOTCORR: precip,
                    date: date.toISOString().split('T')[0]
                });
            }

            return dailyData;
        }

        // Calculate if leaves would be wet
        function calculateLeafWetness(temp, rh, dewPoint) {
            const tempDewDiff = temp - dewPoint;
            return (rh > 90 || tempDewDiff < 2) ? 1 : 0;
        }

        // Calculate Disease Severity Value (Blitecast model)
        function calculateDSV(temp, wetHours) {
            if (wetHours < 10) return 0;
            
            if (temp >= 7 && temp < 12) {
                if (wetHours >= 15) return 2;
                if (wetHours >= 12) return 1;
            } else if (temp >= 12 && temp < 16) {
                if (wetHours >= 12) return 2;
                if (wetHours >= 9) return 1;
            } else if (temp >= 16 && temp < 21) {
                if (wetHours >= 9) return 3;
                if (wetHours >= 6) return 2;
            } else if (temp >= 21 && temp <= 27) {
                if (wetHours >= 12) return 3;
                if (wetHours >= 9) return 2;
            }
            
            return 0;
        }

        // Analyze weather data for blight risk
        function analyzeData(data) {
            const days = data.map(row => {
                const leafWet = calculateLeafWetness(row.T2M, row.RH2M, row.T2MDEW);
                return {
                    ...row,
                    leafWet: leafWet
                };
            });

            days.sort((a, b) => {
                if (a.YEAR !== b.YEAR) return a.YEAR - b.YEAR;
                return a.DOY - b.DOY;
            });

            let cumulativeDSV = 0;
            let riskPeriods = [];
            let currentRisk = null;

            for (let i = 0; i < days.length; i++) {
                const day = days[i];
                const wetHours = day.leafWet * 24;
                const dsv = calculateDSV(day.T2M, wetHours);
                cumulativeDSV += dsv;

                if (dsv === 0 && i > 0) {
                    cumulativeDSV = Math.max(0, cumulativeDSV - 0.5);
                }

                let riskLevel = 'Low';
                if (cumulativeDSV >= 18) riskLevel = 'Severe';
                else if (cumulativeDSV >= 10) riskLevel = 'High';
                else if (cumulativeDSV >= 5) riskLevel = 'Moderate';

                day.cumulativeDSV = cumulativeDSV;
                day.riskLevel = riskLevel;

                if (riskLevel !== 'Low') {
                    if (!currentRisk || currentRisk.end < i - 7) {
                        currentRisk = {
                            start: i,
                            end: i,
                            startDay: day,
                            maxDSV: cumulativeDSV,
                            maxRisk: riskLevel
                        };
                        riskPeriods.push(currentRisk);
                    } else {
                        currentRisk.end = i;
                        currentRisk.endDay = day;
                        currentRisk.maxDSV = Math.max(currentRisk.maxDSV, cumulativeDSV);
                        if (riskLevel === 'Severe' || 
                            (riskLevel === 'High' && currentRisk.maxRisk !== 'Severe')) {
                            currentRisk.maxRisk = riskLevel;
                        }
                    }
                }
            }

            return {
                days: days,
                riskPeriods: riskPeriods
            };
        }

        // Format analysis results
        function formatAnalysisResults(analysis, locationName, timeRange) {
            const now = new Date();
            const isWinter = now.getMonth() < 4 || now.getMonth() > 9; // Before May or after October
            
            let response = `ðŸ“ Location: ${locationName}\n`;
            response += `ðŸ“… Period: ${timeRange.start.toLocaleDateString()} - ${timeRange.end.toLocaleDateString()}\n`;
            response += `â±ï¸ Analysis: ${timeRange.type === 'future' ? 'Forecast' : 'Historical'}\n\n`;

            const days = analysis.days;
            const severeCount = days.filter(d => d.riskLevel === 'Severe').length;
            const highCount = days.filter(d => d.riskLevel === 'High').length;
            const moderateCount = days.filter(d => d.riskLevel === 'Moderate').length;

            // Add context for winter queries
            if (isWinter && timeRange.type === 'future' && !timeRange.season) {
                response += `â„ï¸ Winter Season Note:\n`;
                response += `It's currently winter - potato late blight is not active in cold temperatures (below 7Â°C).\n`;
                response += `Blight typically occurs during the growing season (June-September) when temperatures are 15-25Â°C.\n\n`;
                response += `Try asking: "What was the last blight period in ${locationName}?" to see last growing season's data.\n`;
                return response;
            }

            response += `ðŸ“Š Summary:\n`;
            response += `â€¢ Total days analyzed: ${days.length}\n`;
            response += `â€¢ ðŸ”´ Severe risk days: ${severeCount}\n`;
            response += `â€¢ ðŸŸ  High risk days: ${highCount}\n`;
            response += `â€¢ ðŸŸ¡ Moderate risk days: ${moderateCount}\n\n`;

            if (analysis.riskPeriods.length > 0) {
                response += `âš ï¸ Risk Periods Found:\n\n`;
                analysis.riskPeriods.forEach((period, idx) => {
                    const emoji = period.maxRisk === 'Severe' ? 'ðŸ”´' : 
                                period.maxRisk === 'High' ? 'ðŸŸ ' : 'ðŸŸ¡';
                    
                    response += `${emoji} ${idx + 1}. ${period.maxRisk} Risk (DSV: ${period.maxDSV.toFixed(1)})\n`;
                    response += `   ${period.startDay.date}`;
                    if (period.endDay && period.endDay.date !== period.startDay.date) {
                        response += ` to ${period.endDay.date}`;
                    }
                    response += `\n`;
                    response += `   Avg temp: ${period.startDay.T2M.toFixed(1)}Â°C, Humidity: ${period.startDay.RH2M.toFixed(0)}%\n`;

                    if (timeRange.type === 'past') {
                        response += `   ${period.maxRisk === 'Severe' ? 'âš ï¸ Fungicide should have been applied' : period.maxRisk === 'High' ? 'â„¹ï¸ High risk conditions occurred' : 'â„¹ï¸ Moderate risk conditions'}\n`;
                    } else {
                        if (period.maxRisk === 'Severe') {
                            response += `   âš ï¸ ACTION: Apply fungicide immediately!\n`;
                        } else if (period.maxRisk === 'High') {
                            response += `   âš ï¸ ACTION: Preventative fungicide recommended\n`;
                        } else {
                            response += `   â„¹ï¸ Monitor closely, prepare for treatment\n`;
                        }
                    }
                    response += `\n`;
                });
            } else {
                if (timeRange.season) {
                    response += `âœ… Good news! No significant blight risk detected during the ${timeRange.start.getFullYear()} growing season.\n`;
                    response += `\nThis was likely a favorable year for potato production in ${locationName}!`;
                } else {
                    response += `âœ… No significant blight risk detected during this period.\n`;
                    if (timeRange.type === 'future') {
                        response += `\nConditions are not favorable for blight development. Continue routine monitoring.`;
                    }
                }
            }

            // Add recommendations
            if (timeRange.type === 'future' && (severeCount > 0 || highCount > 0)) {
                response += `\n\nðŸ’¡ Recommendations:\n`;
                response += `â€¢ Have fungicide ready\n`;
                response += `â€¢ Monitor plants daily for symptoms\n`;
                response += `â€¢ Check weather updates frequently\n`;
                response += `â€¢ Consider applying fungicide at first sign of risk\n`;
            }

            return response;
        }

        // Process user questions
        async function processQuestion(question) {
            const lowerQ = question.toLowerCase();

            // Greetings
            if (lowerQ.match(/^(hi|hello|hey|good morning|good afternoon)/)) {
                return "Hello! ðŸ‘‹ I'm your potato blight risk assistant.\n\nJust ask me questions like:\nâ€¢ 'What's the blight risk in Sydney next week?'\nâ€¢ 'Show me risk for Halifax in June'\nâ€¢ 'Analyze Baddeck for the past month'";
            }

            if (lowerQ.includes('thank')) {
                return "You're welcome! Feel free to ask about blight risk in any location or time period. ðŸ˜Š";
            }

            // General blight info
            if (lowerQ.includes('what is blight') || lowerQ.includes('what causes blight')) {
                return "ðŸ‚ Potato Late Blight\n\nCaused by Phytophthora infestans. Favorable conditions:\nâ€¢ Temperature: 15-25Â°C\nâ€¢ High humidity: >90%\nâ€¢ Leaf wetness: 10+ hours\n\nAsk me about specific locations to see when these conditions occur!";
            }

            if (lowerQ.includes('how to prevent') || lowerQ.includes('prevention')) {
                return "ðŸ›¡ï¸ Blight Prevention:\n\n1. Fungicide during high-risk periods\n2. Plant resistant varieties\n3. Proper spacing\n4. Remove infected plants\n5. Monitor weather (that's where I help!)\n\nTry: 'What's the risk in [your location] next week?'";
            }

            // Check if question contains location and time info
            const hasRisk = lowerQ.includes('risk') || lowerQ.includes('blight');
            const hasWhat = lowerQ.includes('what') || lowerQ.includes('show') || lowerQ.includes('analyze');

            if (hasRisk || hasWhat) {
                // Extract location
                const location = await geocodeLocation(question);
                if (!location) {
                    return "I couldn't find that location. Try:\nâ€¢ Sydney, NS\nâ€¢ Halifax\nâ€¢ Baddeck\nâ€¢ Cape Breton\nâ€¢ Nova Scotia";
                }

                // Extract time range
                const timeRange = parseTimeExpression(question);

                // Show fetching message
                addMessage('assistant', `ðŸ” Fetching weather data for ${location.name}...\nâ³ Analyzing ${timeRange.type === 'future' ? 'forecast' : 'historical'} data...`);

                // Fetch and analyze data
                const weatherApiData = await fetchWeatherData(location.lat, location.lon, timeRange);
                
                if (weatherApiData && weatherApiData.useHistoricalProxy) {
                    // Long-range forecast not available - explain limitations
                    return `ðŸ“ Location: ${location.name}\nðŸ“… Period: ${timeRange.start.toLocaleDateString()} - ${timeRange.end.toLocaleDateString()}\n\n` +
                           `âš ï¸ Long-Range Forecast Limitation:\n\n` +
                           `Weather forecasts are only reliable up to 16 days ahead. I can't accurately predict conditions for ${timeRange.start.toLocaleDateString('en-US', {month: 'long', year: 'numeric'})}.\n\n` +
                           `ðŸ”® What I can tell you:\n\n` +
                           `Based on historical patterns in ${location.name}:\n` +
                           `â€¢ **June-July**: Peak blight risk period\n` +
                           `â€¢ **Typical conditions**: 15-20Â°C, high humidity (>85%)\n` +
                           `â€¢ **Critical weeks**: Mid-June through early August\n\n` +
                           `ðŸ’¡ Recommendations:\n` +
                           `â€¢ Start monitoring weather in late May\n` +
                           `â€¢ Have fungicide ready by early June\n` +
                           `â€¢ Check back in May for accurate June forecast\n` +
                           `â€¢ Ask me "What was last year's blight risk?" to see historical patterns`;
                }
                
                if (!weatherApiData) {
                    return "Sorry, I couldn't fetch weather data. Please try again.";
                }

                const weatherDataConverted = convertWeatherData(weatherApiData, location.lat, location.lon);
                const analysis = analyzeData(weatherDataConverted);

                return formatAnalysisResults(analysis, location.name, timeRange);
            }

            return "I can analyze blight risk for any location and time!\n\nTry asking:\nâ€¢ 'What's the risk in Sydney next week?'\nâ€¢ 'Show me Baddeck for past month'\nâ€¢ 'Analyze Halifax in July'\nâ€¢ 'Cape Breton tomorrow'";
        }

        // Add message to chat
        function addMessage(role, content) {
            const messagesDiv = document.getElementById('messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${role}`;
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            
            if (role === 'assistant') {
                const labelDiv = document.createElement('div');
                labelDiv.className = 'assistant-label';
                labelDiv.innerHTML = `
                    <svg width="14" height="14" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
                    </svg>
                    Assistant
                `;
                contentDiv.appendChild(labelDiv);
            }
            
            const textDiv = document.createElement('div');
            textDiv.textContent = content;
            contentDiv.appendChild(textDiv);
            
            messageDiv.appendChild(contentDiv);
            messagesDiv.appendChild(messageDiv);
            
            document.getElementById('chatContainer').scrollTop = document.getElementById('chatContainer').scrollHeight;
        }

        function showLoading() {
            const messagesDiv = document.getElementById('messages');
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'message assistant';
            loadingDiv.id = 'loading';
            loadingDiv.innerHTML = `
                <div class="message-content">
                    <div class="loading">
                        <div class="spinner"></div>
                        <span>Analyzing...</span>
                    </div>
                </div>
            `;
            messagesDiv.appendChild(loadingDiv);
            document.getElementById('chatContainer').scrollTop = document.getElementById('chatContainer').scrollHeight;
        }

        function hideLoading() {
            const loading = document.getElementById('loading');
            if (loading) loading.remove();
        }

        // Send message
        async function sendMessage() {
            const input = document.getElementById('userInput');
            const question = input.value.trim();
            if (!question) return;
            
            addMessage('user', question);
            input.value = '';
            
            showLoading();
            
            try {
                const response = await processQuestion(question);
                hideLoading();
                addMessage('assistant', response);
            } catch (error) {
                hideLoading();
                addMessage('assistant', 'Sorry, something went wrong. Please try again.');
            }
        }

        document.getElementById('sendBtn').addEventListener('click', sendMessage);
        document.getElementById('userInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') sendMessage();
        });

        // File upload still works for manual data
        document.getElementById('fileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(event) {
                try {
                    const text = event.target.result;
                    const lines = text.trim().split('\n');
                    const headers = lines[0].split(/[\t,]/);
                    
                    const parsed = lines.slice(1).map(line => {
                        const values = line.split(/[\t,]/);
                        const row = {};
                        headers.forEach((header, i) => {
                            const value = values[i]?.trim();
                            row[header.trim()] = isNaN(value) ? value : parseFloat(value);
                        });
                        return row;
                    }).filter(row => row.LAT && row.LON);
                    
                    weatherData = parsed;
                    const analysis = analyzeData(parsed);
                    
                    document.getElementById('uploadArea').innerHTML = `
                        <div class="data-loaded">âœ“ Data loaded (${parsed.length} records)</div>
                    `;
                    
                    addMessage('assistant', 
                        `Great! I've loaded ${parsed.length} data points from your file.\n\n` +
                        `The data covers ${analysis.days.length} days. ` +
                        `Found ${analysis.riskPeriods.length} risk period(s).\n\n` +
                        `You can still ask me to fetch live weather data for any location!`
                    );
                } catch (error) {
                    addMessage('assistant', 'Sorry, there was an error reading your file. Please make sure it\'s a valid CSV/TSV file.');
                }
            };
            reader.readAsText(file);
        });
        </script>
    </body>
</html>
